#!/usr/bin/env node
"use strict";var e=require("commander"),n=require("fs"),t=require("path"),i=require("dotenv");function r(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o=r(e),s=r(n),a=r(t),l=r(i);function c(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var m,u,f,d,p,v,g,h,$,y,w={};function b(){if(u)return m;return u=1,m={formatRedInverse:function(e){return`[41m[37m${e}[0m`},formatRed:function(e){return`[31m${e}[0m`},formatYellowInverse:function(e){return`[43m[37m${e}[0m`},formatYellow:function(e){return`[33m${e}[0m`},formatBlueInverse:function(e){return`[44m[37m${e}[0m`},formatBlue:function(e){return`[34m${e}[0m`},formatGreenInverse:function(e){return`[42m[37m${e}[0m`},formatGreen:function(e){return`[32m${e}[0m`}}}function x(){if(d)return f;d=1;const e=s.default,n=l.default,t=b();return f={parseEnvFile:i=>{const r=e.readFileSync(i,"utf8"),o=n.parse(r);return o||(console.error(t.formatRedInverse(`\nFailed to parse ${i}`)),process.exit(1)),Object.keys(o).length||(console.error(t.formatRedInverse(`\n${i} is empty or has no valid variables.`)),process.exit(1)),o},fileExists:async function(n){try{return await e.promises.access(n,e.constants.F_OK),!0}catch{return!1}},validateFileNames:e=>{["schemaName","envName"].forEach((n=>{n in e||(console.error(t.formatRedInverse(`\nMissing required key: ${n}`)),process.exit(1)),"string"!=typeof e[n]&&(console.error(t.formatRedInverse(`\n${n} must be a string`)),process.exit(1))}))},validateDirectory:async function(n){try{(await e.promises.stat(n)).isDirectory()||(console.error(t.formatRed(`[error] ${n} is not a directory.`)),process.exit(1))}catch(e){console.error(t.formatRed(`[error] Failed to access ${n}: ${e.message}`)),process.exit(1)}}}}function E(){if(v)return p;v=1;const e=s.default,n=l.default,t=a.default,i=b(),r=x(),o=async(r,o)=>{const s=e.readFileSync(r,"utf8"),a=n.parse(s),l=e.readFileSync(o,"utf-8").split("\n"),c={};let m=null,u=[];for(const e of l){const n=e.trim();if(!n||n.startsWith("#"))continue;const t=n.indexOf("=");if(t>0&&"\\"!==n[t-1]){m&&(c[m]=u.join("\n"),u=[]);const e=n.slice(0,t).trim(),i=n.slice(t+1);m=e,u.push(i)}else m&&u.push(n)}m&&(c[m]=u.join("\n"));const f=[],d=s.split(/\r?\n/);for(const e of d){const n=e.trim();if(""===n){f.push("");continue}if(n.startsWith("#")){f.push(e);continue}const t=n.indexOf("=");if(-1!==t){const e=n.slice(0,t).trim();if(e in a){let n=c[e]??"";!n.includes("\n")||n.startsWith('"')||n.startsWith("'")||(console.log(i.formatYellow(`ℹ️  Variable "${e}" has multi-line value. Automatically quoting to preserve it.`)),n=`"${n}"`),f.push(`${e}=${n}`)}}}await e.promises.writeFile(o,f.join("\n"),"utf8"),console.log(i.formatGreenInverse(`\nAligned ${t.basename(o)} with ${t.basename(r)}`))};return p={cloneSchemaToEnv:async(n,o,s)=>{const a=t.join(s,n),l=t.join(s,o);await r.fileExists(a)||(console.error(i.formatRedInverse(`\nSchema file ${n} does not exist in ${s}`)),process.exit(1)),await r.fileExists(l)?console.log(i.formatBlue(`\n${o} already exists in ${s}, skipping copy.`)):(await e.promises.copyFile(a,l),console.log(i.formatGreen(`\nCopied ${n} to ${o} in ${s}`)))},alignEnvWithSchema:o,checkEnvVariables:async(n,s,a,l)=>{const c=r.parseEnvFile(n),m=r.parseEnvFile(s),u=Object.keys(c),f=Object.keys(m),d=e.readFileSync(s,"utf-8").split("\n"),p={};for(const e of d){const n=e.trim();if(!n||n.startsWith("#")||!n.includes("="))continue;const[t,...i]=n.split("="),r=i.join("=").trim();p[t.trim()]=r}const v=u.filter((e=>!f.includes(e))),g=u.filter((e=>{if(!f.includes(e)||v.includes(e))return!1;const n=m[e];if("string"!=typeof n)return!1;const t=p[e]??"";if("''"===t||'""'===t)return!1;const i=n.startsWith('"')||n.startsWith("'"),r=n.trim();return""===(i?r:r.split("#")[0].trim())})),h=a?f.filter((e=>!u.includes(e))):[],$=t.dirname(s);if(v.length>0&&(console.error(i.formatRedInverse(`\n[Missing Variables] in ${$}`)),console.log(i.formatRed(`→ ${v.join(", ")}`))),g.length>0&&(console.error(i.formatYellowInverse(`\n[Empty Variables] in ${$}`)),console.log(i.formatYellow(`→ ${g.join(", ")}`))),h.length>0&&(console.error(i.formatBlueInverse(`\n[Extra Variables] in ${$}`)),console.log(i.formatBlue(`→ ${h.join(", ")}`))),a&&l?await o(n,s):!a&&l&&console.log(i.formatYellow('\n[Warning] The "align" option can only be used in strict mode. Skipping alignment.')),v.length>0||g.length>0)process.exit(1);else{const e=`\n      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n      🎉 SUCCESS! ENV CHECK PASSED 🎉\n\n      ✅ All variables in: ${$}\n\n      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n    `;console.log(i.formatGreen(e))}}}}function j(){if(h)return g;h=1;const e=process.cwd(),n=".env.example",t=".env";return g={defaultDir:e,defaultSchemaFileName:n,defaultEnvFileName:t,defaultFiles:{schemaName:n,envName:t},defaultMode:{isStrict:!1,isAlign:!1}}}var N,S={name:"env-aligner",version:"2.0.0",description:"Validate, align, and clone env files (e.g. .env) using a schema file (e.g. .env.example).",keywords:[".env",".env.example","dotenv","environment variables","check","align"],homepage:"https://github.com/ChungYingHo/env-aligner",bugs:{url:"https://github.com/ChungYingHo/env-aligner/issues"},repository:{type:"git",url:"https://github.com/ChungYingHo/env-aligner.git"},contributors:["Jeremy Ho <ag.cyho@gmail.com>(https://jeremyho.tw/)","MJC <5iftisland@gmail.com>(https://github.com/JuiCheng)"],license:"MIT",main:"dist/index.min.js",bin:{"env-aligner":"dist/cli.min.js"},scripts:{test:'echo "Error: no test specified" && exit 1',dev:"rollup -c -w",build:"rmdir /s /q dist && rollup -c"},dependencies:{commander:"^12.1.0",dotenv:"^16.4.5"},devDependencies:{"@eslint/js":"^9.15.0","@rollup/plugin-commonjs":"^28.0.1","@rollup/plugin-json":"^6.1.0",eslint:"^9.15.0",globals:"^15.12.0",rollup:"^2.79.2","rollup-plugin-terser":"^7.0.2"},files:["dist"],engines:{node:">=18.0.0"}};var F=function(){if(N)return w;N=1;const{program:e,Option:n}=o.default,t=function(){if(y)return $;y=1;const e=s.default,n=a.default,t=b(),i=x(),r=E(),{defaultDir:o,defaultFiles:l,defaultMode:c}=j(),m=async({rootDir:s=o,fileNames:a=l,mode:u=c,isClone:f=!1}={})=>{const d={...l,...a};i.validateFileNames(d);const{schemaName:p,envName:v}=d,{isStrict:g,isAlign:h}=u;if(await i.validateDirectory(s),f)return void(await r.cloneSchemaToEnv(p,v,s)&&console.log(t.formatGreen(`✅ env file created successfully in ${s}`)));const $=await e.promises.readdir(s,{withFileTypes:!0}),y=$.map((e=>e.name)),w=n.join(s,p),b=n.join(s,v),x=a.envName!==l.envName,E=a.schemaName!==l.schemaName;if(y.includes(v)){const[e,n]=await Promise.all([i.fileExists(w),i.fileExists(b)]);if(e&&n)return r.checkEnvVariables(w,b,g,h),!0;console.log(t.formatBlue(`[info] Skipping check in ${s}, searching deeper...`))}for(const e of $){if(!e.isDirectory()||["node_modules","dist"].includes(e.name))continue;const t=n.join(s,e.name);if(await m({rootDir:t,fileNames:a,mode:u}))return!0}return(x||E)&&(console.error(t.formatRed(`\n❌ No matching env/schema file found for "${v}" or "${p}" under: ${s}`)),process.exit(1)),!1};return $=m}(),{version:i}=S,r=b(),{defaultDir:l,defaultSchemaFileName:c,defaultEnvFileName:m}=j();e.name("env-aligner").description("A simple tool to align the env variables in the project").version(i,"-v","--version").showSuggestionAfterError().addHelpText("beforeAll",(()=>{console.log(r.formatGreen("Env Aligner is working!"))})).addOption(new n("--dir <directory>","Root directory to scan.").default(l)).addOption(new n("--schema <schema>","Schema file name.").default(c)).addOption(new n("--env <env>","Env file name.").default(m)).addOption(new n("--strict","Enable strict mode: warn on extra variables.").default(!1)).addOption(new n("--align","Enable align mode: auto-fix env format (only works with --strict).").default(!1)).addOption(new n("--clone","Clone schema to env file if env does not exist.").default(!1)).addHelpText("after","\n    Examples:\n        $ env-aligner --dir ./apps/frontend\n        $ env-aligner\n        $ env-aligner --schema .env.example --env .env\n        $ env-aligner --schema .env.example\n        $ env-aligner --env .env\n        $ env-aligner --strict --align\n        $ env-aligner --clone\n    ").parse(process.argv);const u=e.opts();u.align&&!u.strict&&console.log(r.formatYellow("⚠️  Align mode (--align) only works when strict mode (--strict) is enabled. It will be ignored."));const f=u.strict,d=f&&u.align;return t({rootDir:u.dir,fileNames:{schemaName:u.schema,envName:u.env},mode:{isStrict:f,isAlign:d},isClone:u.clone}),w}(),k=c(F);module.exports=k;
//# sourceMappingURL=cli.min.js.map
