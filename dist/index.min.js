"use strict";var e=require("fs"),r=require("path"),s=require("dotenv"),o=require("chalk");function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var n,t,a=i(e),c=i(r),l=i(s),u=i(o);function d(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var h=d(function(){if(t)return n;t=1;const e=a.default,r=c.default,s=l.default,o=u.default,i=process.cwd(),d={schemaName:".env.example",envName:".env"},h={isCheckMissing:!0,isCheckEmptyValue:!0,isCheckExtra:!0},f=r=>{const i=e.readFileSync(r,"utf8"),n=s.parse(i);return n||(console.error(o.red.inverse(`\nFailed to parse ${r}`)),process.exit(1)),n},m=(e,s,i)=>{const n={...h,...i};var t;t=n,["isCheckMissing","isCheckEmptyValue","isCheckExtra"].forEach((e=>{e in t||(console.error(o.red.inverse(`\nMissing required key: ${e}`)),process.exit(1)),"boolean"!=typeof t[e]&&(console.error(o.red.inverse(`\n${e} must be a boolean`)),process.exit(1))}));const{isCheckMissing:a,isCheckEmptyValue:c,isCheckDuplicate:l,isCheckExtra:u}=n;a||c||l||u||console.log(o.hex("#ff69b4").inverse("You have disabled all checks, nothing to do."));const d=f(e),m=f(s),p=Object.keys(d),v=Object.keys(m),y=a?p.filter((e=>!v.includes(e))):[],g=c?p.filter((e=>d[e]&&!m[e]&&!y.includes(e))):[],k=u?v.filter((e=>!p.includes(e))):[],b=r.dirname(s);y.length>0&&(console.error(o.red.inverse(`\nMissing variables in ${b}`)),console.log(o.red(`${y.join("、")}`))),g.length>0&&(console.error(o.hex("#FFA500").inverse(`\nEmpty value variables in ${b}`)),console.log(o.hex("#FFA500")(`${g.join("、")}`))),k.length>0&&(console.error(o.blue.inverse(`\nExtra variables in ${b}`)),console.log(o.blue(`${k.join("、")}`))),y.length>0||g.length>0?process.exit(1):console.log(o.green.inverse(`\nAll variables in ${b} are correct!`))},p=async({rootDir:s=i,fileNames:n=d,checkOptions:t=h}={})=>{"use default"===s&&(s=i);try{if(!(await e.promises.stat(s)).isDirectory())throw new Error(`${s} is not a valid directory`)}catch(e){console.error(o.red(`\nError: ${s} does not exist or is not accessible.`)),process.exit(1)}const a={...d,...n};(e=>{["schemaName","envName"].forEach((r=>{r in e||(console.error(o.red.inverse(`\nMissing required key: ${r}`)),process.exit(1)),"string"!=typeof e[r]&&(console.error(o.red.inverse(`\n${r} must be a string`)),process.exit(1))}))})(a);const{schemaName:c,envName:l}=a,u=await e.promises.readdir(s,{withFileTypes:!0});await Promise.all(u.map((async i=>{const a=r.join(s,i.name);if(i.isDirectory()&&"node_modules"!==i.name&&"dist"!==i.name)await p({rootDir:a,fileNames:n,checkOptions:t});else if(i.isFile()&&i.name===c){const i=r.join(s,l);try{await e.promises.stat(i),m(a,i,t)}catch(e){console.warn(o.yellow(`\nNo matching env file found for ${a}`))}}})))};return n=p}());module.exports=h;
//# sourceMappingURL=index.min.js.map
