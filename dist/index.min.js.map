{"version":3,"file":"index.min.js","sources":["../src/lib/colorFormat.js","../src/lib/fileReader.js","../src/lib/envHandler.js","../src/lib/index.js?commonjs-entry","../src/lib/index.js","../src/constant/default.js"],"sourcesContent":["// 紅底白字\r\nfunction formatRedInverse (msg) {\r\n  return `\\x1b[41m\\x1b[37m${msg}\\x1b[0m`\r\n}\r\n\r\n// 紅字\r\nfunction formatRed (msg) {\r\n  return `\\x1b[31m${msg}\\x1b[0m`\r\n}\r\n\r\n// 黃底白字\r\nfunction formatYellowInverse (msg) {\r\n  return `\\x1b[43m\\x1b[37m${msg}\\x1b[0m`\r\n}\r\n\r\n// 黃字\r\nfunction formatYellow (msg) {\r\n  return `\\x1b[33m${msg}\\x1b[0m`\r\n}\r\n\r\n// 藍底白字\r\nfunction formatBlueInverse (msg) {\r\n  return `\\x1b[44m\\x1b[37m${msg}\\x1b[0m`\r\n}\r\n\r\n// 藍字\r\nfunction formatBlue (msg) {\r\n  return `\\x1b[34m${msg}\\x1b[0m`\r\n}\r\n\r\n// 綠底白字\r\nfunction formatGreenInverse (msg) {\r\n  return `\\x1b[42m\\x1b[37m${msg}\\x1b[0m`\r\n}\r\n\r\n// 綠字\r\nfunction formatGreen (msg) {\r\n  return `\\x1b[32m${msg}\\x1b[0m`\r\n}\r\n\r\nmodule.exports = {\r\n  formatRedInverse,\r\n  formatRed,\r\n  formatYellowInverse,\r\n  formatYellow,\r\n  formatBlueInverse,\r\n  formatBlue,\r\n  formatGreenInverse,\r\n  formatGreen\r\n}","const fs = require('fs')\r\nconst dotenv = require('dotenv')\r\nconst colorFormat = require('./colorFormat')\r\n\r\n/**\r\n * 解析環境變數\r\n * @param {string} filePath\r\n * @returns 應回傳一個物件，包含了檔案中的環境變數\r\n */\r\nconst parseEnvFile = (filePath) => {\r\n  const fileContent = fs.readFileSync(filePath, 'utf8')\r\n  const parsedContent = dotenv.parse(fileContent)\r\n\r\n  if (!parsedContent) {\r\n    console.error(colorFormat.formatRedInverse(`\\nFailed to parse ${filePath}`))\r\n    process.exit(1)\r\n  }\r\n\r\n  if (!Object.keys(parsedContent).length) {\r\n    console.error(colorFormat.formatRedInverse(`\\n${filePath} is empty or has no valid variables.`))\r\n    process.exit(1)\r\n  }\r\n\r\n  return parsedContent\r\n}\r\n\r\n/**\r\n * 檢查檔案是否存在\r\n * @param {string} targetPath\r\n * @returns {Promise<boolean>} 如果檔案存在則回傳 true，否則回傳 false\r\n */\r\nasync function fileExists (targetPath) {\r\n  try {\r\n    await fs.promises.access(targetPath, fs.constants.F_OK)\r\n    return true\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * 這個函式會檢查 fileNames 物件是否有缺少必要的 key 或是 key 的值不是 string\r\n * @param {string} fileNames\r\n */\r\nconst validateFileNames = (fileNames) => {\r\n  const requiredKeys = ['schemaName', 'envName']\r\n\r\n  requiredKeys.forEach(key => {\r\n    if(!(key in fileNames)) {\r\n      console.error(colorFormat.formatRedInverse(`\\nMissing required key: ${key}`))\r\n      process.exit(1)\r\n    }\r\n\r\n    if (typeof fileNames[key] !== 'string') {\r\n      console.error(colorFormat.formatRedInverse(`\\n${key} must be a string`))\r\n      process.exit(1)\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * 驗證指定路徑是否為有效資料夾\r\n * @param {string} dirPath - 要驗證的目錄路徑\r\n */\r\nasync function validateDirectory (dirPath) {\r\n  try {\r\n    const stats = await fs.promises.stat(dirPath)\r\n    if (!stats.isDirectory()) {\r\n      console.error(colorFormat.formatRed(`[error] ${dirPath} is not a directory.`))\r\n      process.exit(1)\r\n    }\r\n  } catch (error) {\r\n    console.error(colorFormat.formatRed(`[error] Failed to access ${dirPath}: ${error.message}`))\r\n    process.exit(1)\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  parseEnvFile,\r\n  fileExists,\r\n  validateFileNames,\r\n  validateDirectory\r\n}","const fs = require('fs')\r\nconst dotenv = require('dotenv')\r\nconst path = require('path')\r\nconst colorFormat = require('./colorFormat')\r\nconst fileReader = require('./fileReader')\r\n/**\r\n * 從 schema 複製出 .env 檔案（如果不存在）\r\n * @param {string} rootDir 資料夾路徑\r\n * @param {string} schemaFileName schema 檔案名稱（預設 .env.example）\r\n * @param {string} envFileName 要產出的 .env 檔名（預設 .env）\r\n */\r\n\r\nconst cloneSchemaToEnv = async (schemaFileName, envFileName, rootDir) => {\r\n  const schemaFilePath = path.join(rootDir, schemaFileName)\r\n  const envFilePath = path.join(rootDir, envFileName)\r\n\r\n  // 檢查 schema 檔案是否存在\r\n  if (!(await fileReader.fileExists(schemaFilePath))) {\r\n    console.error(colorFormat.formatRedInverse(`\\nSchema file ${schemaFileName} does not exist in ${rootDir}`))\r\n    process.exit(1)\r\n  }\r\n\r\n  // 如果 .env 檔案不存在，則複製 schema 檔案到 .env\r\n  if (!(await fileReader.fileExists(envFilePath))) {\r\n    await fs.promises.copyFile(schemaFilePath, envFilePath)\r\n    console.log(colorFormat.formatGreen(`\\nCopied ${schemaFileName} to ${envFileName} in ${rootDir}`))\r\n  } else {\r\n    console.log(colorFormat.formatBlue(`\\n${envFileName} already exists in ${rootDir}, skipping copy.`))\r\n  }\r\n}\r\n\r\n/**\r\n * 根據 schema 對齊 .env 檔案的格式與變數順序\r\n * 支援多行變數值（例如憑證）\r\n */\r\nconst alignEnvWithSchema = async (schemaFilePath, envFilePath) => {\r\n  const schemaRaw = fs.readFileSync(schemaFilePath, 'utf8')\r\n  const schemaVars = dotenv.parse(schemaRaw)\r\n\r\n  // 解析 env 並保留 \"\"、'' 判斷\r\n  const envRawLines = fs.readFileSync(envFilePath, 'utf-8').split('\\n')\r\n  const envRawMap = {}\r\n  let currentKey = null\r\n  let buffer = []\r\n\r\n  for (const line of envRawLines) {\r\n    const trimmed = line.trim()\r\n\r\n    if (!trimmed || trimmed.startsWith('#')) continue\r\n\r\n    const equalIndex = trimmed.indexOf('=')\r\n    const hasNewAssignment = equalIndex > 0 && trimmed[equalIndex - 1] !== '\\\\'\r\n\r\n    if (hasNewAssignment) {\r\n      if (currentKey) {\r\n        envRawMap[currentKey] = buffer.join('\\n')\r\n        buffer = []\r\n      }\r\n\r\n      const key = trimmed.slice(0, equalIndex).trim()\r\n      const value = trimmed.slice(equalIndex + 1)\r\n      currentKey = key\r\n      buffer.push(value)\r\n    } else if (currentKey) {\r\n      buffer.push(trimmed)\r\n    }\r\n  }\r\n\r\n  if (currentKey) {\r\n    envRawMap[currentKey] = buffer.join('\\n')\r\n  }\r\n\r\n  // 開始對齊\r\n  const outputLines = []\r\n  const schemaLines = schemaRaw.split(/\\r?\\n/)\r\n\r\n  for (const originalLine of schemaLines) {\r\n    const trimmed = originalLine.trim()\r\n\r\n    if (trimmed === '') {\r\n      outputLines.push('')\r\n      continue\r\n    }\r\n\r\n    if (trimmed.startsWith('#')) {\r\n      outputLines.push(originalLine)\r\n      continue\r\n    }\r\n\r\n    const equalIndex = trimmed.indexOf('=')\r\n    if (equalIndex !== -1) {\r\n      const key = trimmed.slice(0, equalIndex).trim()\r\n\r\n      if (key in schemaVars) {\r\n        let value = envRawMap[key] ?? ''\r\n        const needsQuote = value.includes('\\n')\r\n\r\n        if (needsQuote && !(value.startsWith('\"') || value.startsWith(\"'\"))) {\r\n          console.log(colorFormat.formatYellow(`ℹ️  Variable \"${key}\" has multi-line value. Automatically quoting to preserve it.`))\r\n          value = `\"${value}\"`\r\n        }\r\n\r\n        outputLines.push(`${key}=${value}`)\r\n      }\r\n    }\r\n  }\r\n\r\n  await fs.promises.writeFile(envFilePath, outputLines.join('\\n'), 'utf8')\r\n\r\n  console.log(\r\n    colorFormat.formatGreenInverse(\r\n      `\\nAligned ${path.basename(envFilePath)} with ${path.basename(schemaFilePath)}`\r\n    )\r\n  )\r\n}\r\n\r\n/**\r\n * 會檢查 schema 檔案中的變數是否都有在 env 檔案中出現\r\n * @param {string} schemaFilePath\r\n * @param {string} envFilePath\r\n */\r\nconst checkEnvVariables = async (schemaFilePath, envFilePath, isStrict, isAlign) => {\r\n  const schemaVars = fileReader.parseEnvFile(schemaFilePath)\r\n  const envVars = fileReader.parseEnvFile(envFilePath)\r\n  const schemaKeys = Object.keys(schemaVars)\r\n  const envKeys = Object.keys(envVars)\r\n\r\n  const envRawLines = fs.readFileSync(envFilePath, 'utf-8').split('\\n')\r\n  const envRawMap = {}\r\n  for (const line of envRawLines) {\r\n    const trimmed = line.trim()\r\n    if (!trimmed || trimmed.startsWith('#') || !trimmed.includes('=')) continue\r\n    const [key, ...rest] = trimmed.split('=')\r\n    const value = rest.join('=').trim()\r\n    envRawMap[key.trim()] = value\r\n  }\r\n\r\n  const missingKeys = schemaKeys.filter(key => !envKeys.includes(key))\r\n  const emptyValueKeys = schemaKeys.filter(\r\n    key => {\r\n      if (!envKeys.includes(key) || missingKeys.includes(key)) return false\r\n\r\n      const rawValue = envVars[key]\r\n      if (typeof rawValue !== 'string') return false\r\n\r\n      // 用原始 map 判斷是否填了 '' 或 \"\"\r\n      const rawString = envRawMap[key] ?? ''\r\n      if (rawString === \"''\" || rawString === '\"\"') return false\r\n\r\n      const isQuoted = rawValue.startsWith('\"') || rawValue.startsWith(\"'\")\r\n      const trimmed = rawValue.trim()\r\n\r\n      const valueWithoutComment = !isQuoted\r\n        ? trimmed.split('#')[0].trim()\r\n        : trimmed\r\n\r\n      return valueWithoutComment === ''\r\n    }\r\n  )\r\n\r\n  const extraKeys = isStrict ? envKeys.filter(key => !schemaKeys.includes(key)) : []\r\n\r\n  const envDir = path.dirname(envFilePath)\r\n\r\n  if (missingKeys.length > 0) {\r\n    console.error(colorFormat.formatRedInverse(`\\n[Missing Variables] in ${envDir}`))\r\n    console.log(colorFormat.formatRed(`→ ${missingKeys.join(', ')}`))\r\n  }\r\n\r\n  if (emptyValueKeys.length > 0) {\r\n    console.error(colorFormat.formatYellowInverse(`\\n[Empty Variables] in ${envDir}`))\r\n    console.log(colorFormat.formatYellow(`→ ${emptyValueKeys.join(', ')}`))\r\n  }\r\n\r\n  if (extraKeys.length > 0) {\r\n    console.error(colorFormat.formatBlueInverse(`\\n[Extra Variables] in ${envDir}`))\r\n    console.log(colorFormat.formatBlue(`→ ${extraKeys.join(', ')}`))\r\n  }\r\n\r\n  if (isStrict && isAlign) {\r\n    await alignEnvWithSchema(schemaFilePath, envFilePath)\r\n  } else if (!isStrict && isAlign) {\r\n    console.log(colorFormat.formatYellow(\r\n      `\\n[Warning] The \"align\" option can only be used in strict mode. Skipping alignment.`\r\n    ))\r\n  }\r\n\r\n  if (missingKeys.length > 0 || emptyValueKeys.length > 0 ) {\r\n    process.exit(1)\r\n  } else {\r\n    const msg = `\r\n      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n      🎉 SUCCESS! ENV CHECK PASSED 🎉\r\n\r\n      ✅ All variables in: ${envDir}\r\n\r\n      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n    `\r\n    console.log(colorFormat.formatGreen(msg))\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  cloneSchemaToEnv,\r\n  alignEnvWithSchema,\r\n  checkEnvVariables\r\n}","import { getDefaultExportFromCjs } from \"\u0000commonjsHelpers.js\";\nimport { __require as requireLib } from \"C:\\\\Users\\\\User\\\\Desktop\\\\VScode\\\\env-aligner\\\\src\\\\lib\\\\index.js\";\nvar libExports = requireLib();\nexport { libExports as __moduleExports };\nexport default /*@__PURE__*/getDefaultExportFromCjs(libExports);","const fs = require('fs')\r\nconst path = require('path')\r\nconst colorFormat = require('./colorFormat')\r\nconst fileReader = require('./fileReader')\r\nconst envHandler = require('./envHandler')\r\nconst { defaultDir, defaultFiles, defaultMode } = require('../constant/default')\r\n\r\n/**\r\n * envAligner：主程式入口，用於驗證或建立各資料夾中的 .env 檔案。\r\n * \r\n * 支援功能：\r\n * 1. 遞迴檢查指定目錄與子目錄下的 `.env` 與 schema（預設為 `.env.example`）\r\n * 2. 可啟用嚴格模式（isStrict）檢查多餘變數\r\n * 3. 可啟用對齊模式（isAlign）自動修正 .env 格式\r\n * 4. 可啟用複製模式（isClone）從 schema 建立 .env 檔案（若不存在）\r\n * \r\n * @param {Object} options\r\n * @param {string} [options.rootDir] - 根目錄路徑，預設為 process.cwd()\r\n * @param {Object} [options.fileNames] - 自定義檔名（例如 `{ schemaName: '.env.example', envName: '.env' }`）\r\n * @param {Object} [options.mode] - 模式控制物件 `{ isStrict?: boolean, isAlign?: boolean }`\r\n * @param {boolean} [options.isClone] - 是否為複製模式，預設為 false\r\n * \r\n * @returns {Promise<boolean>} - 若成功完成檢查或建立，回傳 true，否則遞迴至下一層\r\n */\r\n\r\nconst envAligner = async ({\r\n  rootDir = defaultDir,\r\n  fileNames = defaultFiles,\r\n  mode = defaultMode,\r\n  isClone = false\r\n} = {}) => {\r\n\r\n  const mergedFileNames = { ...defaultFiles, ...fileNames }\r\n  // 檢查檔案名稱是否正確\r\n  fileReader.validateFileNames(mergedFileNames)\r\n\r\n  const { schemaName: schemaFileName, envName: envFileName } = mergedFileNames\r\n  const { isStrict, isAlign } = mode\r\n\r\n  // 確保目錄存在且為資料夾\r\n  await fileReader.validateDirectory(rootDir)\r\n\r\n  // 若 isClone 為 true，則嘗試複製 schema 檔案到 env 檔案\r\n  if (isClone) {\r\n    const didClone = await envHandler.cloneSchemaToEnv(schemaFileName, envFileName, rootDir)\r\n    if (didClone) {\r\n      console.log(colorFormat.formatGreen(`✅ env file created successfully in ${rootDir}`))\r\n    }\r\n    return\r\n  }\r\n\r\n  // 讀取目錄內容\r\n  const dirContents = await fs.promises.readdir(rootDir, { withFileTypes: true })\r\n  const directoryEntries = dirContents.map(entry => entry.name)\r\n\r\n  // 組合 schema 和 env 檔案的完整路徑\r\n  const schemaFilePath = path.join(rootDir, schemaFileName)\r\n  const envFilePath = path.join(rootDir, envFileName)\r\n\r\n  // 檢查是否為使用者指定的 env/schema\r\n  const isEnvExplicit = fileNames.envName !== defaultFiles.envName\r\n  const isSchemaExplicit = fileNames.schemaName !== defaultFiles.schemaName\r\n\r\n  // 若有 .env 檔案，執行比對並停止遞迴\r\n  if (directoryEntries.includes(envFileName)) {\r\n    const [schemaExists, envExists] = await Promise.all([\r\n      fileReader.fileExists(schemaFilePath),\r\n      fileReader.fileExists(envFilePath)\r\n    ])\r\n\r\n    if (schemaExists && envExists) {\r\n      envHandler.checkEnvVariables(schemaFilePath, envFilePath, isStrict, isAlign)\r\n\r\n      return true\r\n    } else {\r\n      console.log(\r\n        colorFormat.formatBlue(`[info] Skipping check in ${rootDir}, searching deeper...`)\r\n      )\r\n    }\r\n  }\r\n\r\n  // 否則遞迴檢查子目錄\r\n  for (const item of dirContents) {\r\n    if (!item.isDirectory() || ['node_modules', 'dist'].includes(item.name)) {\r\n      continue\r\n    }\r\n\r\n    const subDirPath = path.join(rootDir, item.name)\r\n    const isChecked = await envAligner({ rootDir: subDirPath, fileNames, mode })\r\n\r\n    if (isChecked) return true\r\n  }\r\n\r\n  // 若完全沒找到符合條件的檔案\r\n  if (isEnvExplicit || isSchemaExplicit) {\r\n    console.error(colorFormat.formatRed(\r\n      `\\n❌ No matching env/schema file found for \"${envFileName}\" or \"${schemaFileName}\" under: ${rootDir}`\r\n    ))\r\n    process.exit(1)\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nmodule.exports = envAligner","const defaultDir = process.cwd()\r\nconst defaultSchemaFileName = '.env.example'\r\nconst defaultEnvFileName = '.env'\r\nconst defaultFiles = {\r\n  schemaName: defaultSchemaFileName,\r\n  envName: defaultEnvFileName\r\n}\r\nconst defaultMode = {\r\n  isStrict: false,\r\n  isAlign: false\r\n}\r\n\r\nmodule.exports = {\r\n  defaultDir,\r\n  defaultSchemaFileName,\r\n  defaultEnvFileName,\r\n  defaultFiles,\r\n  defaultMode\r\n}"],"names":["colorFormat","formatRedInverse","msg","formatRed","formatYellowInverse","formatYellow","formatBlueInverse","formatBlue","formatGreenInverse","formatGreen","fs","require$$0","dotenv","require$$1","require$$2","fileReader","parseEnvFile","filePath","fileContent","readFileSync","parsedContent","parse","console","error","process","exit","Object","keys","length","fileExists","async","targetPath","promises","access","constants","F_OK","validateFileNames","fileNames","forEach","key","validateDirectory","dirPath","stat","isDirectory","message","path","require$$3","require$$4","alignEnvWithSchema","schemaFilePath","envFilePath","schemaRaw","schemaVars","envRawLines","split","envRawMap","currentKey","buffer","line","trimmed","trim","startsWith","equalIndex","indexOf","join","slice","value","push","outputLines","schemaLines","originalLine","includes","log","writeFile","basename","envHandler","cloneSchemaToEnv","schemaFileName","envFileName","rootDir","copyFile","checkEnvVariables","isStrict","isAlign","envVars","schemaKeys","envKeys","rest","missingKeys","filter","emptyValueKeys","rawValue","rawString","isQuoted","extraKeys","envDir","dirname","libExports","defaultDir","defaultFiles","defaultMode","cwd","defaultSchemaFileName","defaultEnvFileName","_default","schemaName","envName","require$$5","envAligner","mode","isClone","mergedFileNames","dirContents","readdir","withFileTypes","directoryEntries","map","entry","name","isEnvExplicit","isSchemaExplicit","schemaExists","envExists","Promise","all","item","subDirPath","lib","requireLib","index","getDefaultExportFromCjs"],"mappings":"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"}